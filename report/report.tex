%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Example: Project Report
%
% Source: http://www.howtotex.com
%
% Feel free to distribute this example, but please keep the referral
% to howtotex.com
% Date: March 2011 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Edit the title below to update the display in My Documents
%\title{Project Report}
%
%%% Preamble
\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage{fourier}

\usepackage[english]{babel}                                                         % English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}  
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}   
\usepackage{url}
\usepackage{listings}

%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}                                            % No page header
\fancyfoot[L]{}                                         % Empty 
\fancyfoot[C]{}                                         % Empty
\fancyfoot[R]{\thepage}                                 % Pagenumbering
\renewcommand{\headrulewidth}{0pt}          % Remove header underlines
\renewcommand{\footrulewidth}{0pt}              % Remove footer underlines
\setlength{\headheight}{13.6pt}


%%% Equation and float numbering
\numberwithin{equation}{section}        % Equationnumbering: section.eq#
\numberwithin{figure}{section}          % Figurenumbering: section.fig#
\numberwithin{table}{section}               % Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}}     % Horizontal rule

\title{
        %\vspace{-1in}  
        \usefont{OT1}{bch}{b}{n}
        \horrule{0.5pt} \\[0.4cm]
        \huge Optimizing Single Core Matrix Multiply \\
        \horrule{2pt} \\[0.5cm]
}
\author{
        \normalfont                                 \normalsize
        Group 2\\[-3pt]      \normalsize
        \today
}
\date{}


%%% Begin document
\begin{document}

\maketitle

\section{Intro}
Matrix multiplication is a ubiquitous operation in science and engineering,
and thus the efficient and fast computation of matrix products is essential.
This report serves as an initial report into tuning the performance of matrix
multiplication on a single core.

\subsection{Matrix Multiplication}
Throughout this report, we will consider the problem of computing
$C = A B$, where $C, A, B$ are $M \times M$ square matrices.

\begin{lstlisting}[frame = single, caption={Naive Square Matrix Multiply}]
void square dgemm(const int M, 
                  const double *A, const double *B, double *C)
{
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < M; ++j) {
            for (int k = 0; k < M; ++k) {
                C[j*M+i] += A[k*M+i] * B[j*M+k];
            }
        }
    }
}
\end{lstlisting}

\subsection{Testing specs}

\section{Optimization strategies}

At this time, two different optimization strategies have been implemented and
tested: 

\subsection{Loop ordering}
Notice that in the naive matrix multiply implementation, the innermost loop
is where all the work is done.  Thus, the order of the loops does not matter.
Noting this, we can choose the loop order that best regularizes memory access.
Ideally, we would like to access the arrays with stride 1, and this motivates the
idea that the `i' variable in the above naive code should be looped over in the 
innermost loop, as then we are accessing C and A with stride one.  This results in 
the following code:

\begin{lstlisting}[frame = single, caption={Improved Loop Order Square Matrix Multiply}]
void square dgemm(const int M, 
                  const double *A, const double *B, double *C)
{
    for (int j = 0; j < M; ++j) {
        for (int k = 0; k < M; ++k) {
            double bkj = B[j*M+k];
            for (int i = 0; i < M; ++i)
                C[j*M+i] += A[k*M+i] * bkj;
        }
    }
}
\end{lstlisting}

This optimization is supported empirically, as all possible loop orders were
tested (see Figure~\ref{fig:loop_order}).

This basic optimization brings the naive matrix multiple up to the speed of
the provided Fortran code (see Figure~\ref{loop_order_opt_comparison}).

\begin{figure}
    \centering
    \includegraphics[width=6.0in]{../timings/timings loop order.pdf}
    \caption{Results for all possible loop orders}
    \label{fig:loop_order}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=6.0in]{../timings/timing show jki good.pdf}
    \caption{Loop order optimization comparison}
    \label{fig:loop_order_opt_comparison}
\end{figure}

\subsection{Block and Copy Optimization}
In order to encourage cache reuse, and thus reducing the overhead of loading 
data from main memory when performing the floating point operations, it may make
sense to partition the matrices 

\section{Future Work}



%%% End document
\end{document}